---
title: "C2_Week4Mkd"
output: html_document
---

**La funcion str**

La funcion str muestra de forma compacta la estructura interna de un objeto en R.

Es especialmente adecuado para mostrar de forma compacta el contenido de listas de manera abreviada, es similar a la funcin summary.

El objetivo de esta pregunta es el responder, Â¿Que hay en este objeto?

```{r}
str(str)

# nos muestra que es una funcion que toma cualquier objeto
```
```{r}
x <- rnorm(100, 2, 4)
summary(x)

# usando la funcion str, nos da informacion sobre el numero de elementos y nos proporciona los primeros 5 elementos.
str(x)
```
**Simulando numeros aleatorios**

Las funciones de probabilidad usualmente tienen 4 funciones asociadas a ellas, el prefijo de cada funcion esta dado por

d para densidad

r para generar numeros aleatorios

p para la distribucion acumulada 

q para la funcion quantile (se puede pensar como si evaluaramos la inversa de la funcion de distribucion en un valor que se desee)


Fijando el numero aleatorio "la semilla", con set.seed, podemos repetir muestras de numeros aleatorios
```{r}
set.seed(1)
rnorm(5)

set.seed(1)
rnorm(5)
```
Siempre que se haga una simulacion hay que fijar el numero de semilla, para poder reproducir los resultados obtenidos.

```{r}
# distribucion acumulada

ppois(4, lambda = 2) # P(x <= 4), con x distribucion poisson con media 2

```
**Simulando un modelo lineal**

Supongamos que queremos simular el siguiente modelo lineal

y = beta_0 + beta_1*x + epsilon

Donde epsilon se distribuye normal(0, 2^2). Supongamos que x se distrubuye normal(0,1) y beta_0 = 0.5 y beta_1 = 2

Para esto, podemos simularlo de la siguiente manera
```{r}
set.seed(20)
x <- rnorm(100)
e <- rnorm(100, 0 , 2)
y <- 0.5 + 2*x + e
plot(x, y)
```
**Muestra aleatoria**

Para esto usamos la funcion sample, la cual no da como resultado una catidad fija de datos aleatorios, por ejemplo
```{r}
set.seed(1)
sample(1:10, 4)
# generamos 4 numeros aleatorios entre 1 y 10

sample(letters, 5)
# generamos 5 letras de forma aleatoria

sample(1:10)
# nos da como resultado una permutacio de los numeros del 1 al 10

sample(1:10, replace = T)
# muestra aleatoria con valores repetidos
```
"Profiling" es una manera sistematica de examinar cuanto tiempo es invertido en diferentes partes del codigo. Es util para optimizar el codigo.

**Usando system.time()**

Toma una expresion de R como entrada y regresa la cantidad de tiempo requerido para evaluar la expresion, dicho tiempo lo calcula en segundos y si hay un error, da el tiempo hasta que el error ocurrio. Regresa un objeto de clase proc_time , donde user time es el tiempo "para la computadora" para ejecutar el codigo, y "elapsed time" es el tiempo que nosotros percibimos

**Usando Rprof()**

Con esta funcion iniciamos el "profiler" en R.

La funcion summaryRprof() resume la salida de Rprof() (de otra manera no es legible).

NUNCA USAR system.time() y Rprof() JUNTAS.

Al usar la funcion summaryRprof(), hay dos formas de normalizar los datos: "by.total" <- que divide el tiempo requerido en cada funcion entre el tiempo total. "by.self" <- hace lo mismo pero primero resta el tiempo requerido en funciones precedentes en la pila de llamada 
